```bash
──(komugi㉿komugi)-[~/Desktop]
└─$ gdb -q moving_immediate_data
Reading symbols from moving_immediate_data...
(No debugging symbols found in moving_immediate_data)
(gdb) b _start
Breakpoint 1 at 0x8049000
(gdb) r
Starting program: /home/komugi/Desktop/moving_immediate_data 

Breakpoint 1, 0x08049000 in _start ()
(gdb) disas
Dump of assembler code for function _start:
=> 0x08049000 <+0>:     nop
End of assembler dump.
(gdb) si
0x08049001 in mov_immediate_data_to_register ()
(gdb) disas
Dump of assembler code for function mov_immediate_data_to_register:
=> 0x08049001 <+0>:     mov    $0x64,%eax
   0x08049006 <+5>:     movb   $0x50,0x804a000
End of assembler dump.
(gdb) si
0x08049006 in mov_immediate_data_to_register ()
(gdb) i r
eax            0x64                100
ecx            0x0                 0
edx            0x0                 0
ebx            0x0                 0
esp            0xffffcfc0          0xffffcfc0
ebp            0x0                 0x0
esi            0x0                 0
edi            0x0                 0
eip            0x8049006           0x8049006 <mov_immediate_data_to_register+5>
eflags         0x202               [ IF ]
cs             0x23                35
ss             0x2b                43
ds             0x2b                43
es             0x2b                43
fs             0x0                 0
gs             0x0                 0

gdb) si
0x0804900d in exit ()
(gdb) disas
Dump of assembler code for function exit:
=> 0x0804900d <+0>:     mov    $0x1,%eax
   0x08049012 <+5>:     mov    $0x0,%ebx
   0x08049017 <+10>:    int    $0x80
End of assembler dump.
(gdb) print /x buffer
'buffer' has unknown type; cast it to its declared type
(gdb) print /x buffer 
'buffer' has unknown type; cast it to its declared type
(gdb) print /x
The history is empty.
(gdb) x/xb
Argument required (starting display address).
(gdb) 

```

---

### **Step-by-Step Analysis**

1. **Loading the Program in GDB:**
   ```bash
   gdb -q moving_immediate_data
   ```
   - You opened the binary in GDB, but there are no debugging symbols (`(No debugging symbols found...)`). This is because the program was likely compiled without the `-g` flag, which includes debugging information.

2. **Setting a Breakpoint at `_start`:**
   ```bash
   b _start
   ```
   - This sets a breakpoint at the program's entry point `_start`.

3. **Starting Execution:**
   ```bash
   r
   ```
   - The program starts, and execution stops at the `_start` label due to the breakpoint.

4. **Disassembling `_start`:**
   ```bash
   disas
   ```
   - The disassembler reveals a single instruction at `_start`:
     ```
     0x08049000 <+0>: nop
     ```
     - The `nop` instruction does nothing and is often used for alignment or as a placeholder.

5. **Single-Stepping (`si`):**
   ```bash
   si
   ```
   - Single-stepping advances execution to the next instruction, entering the `mov_immediate_data_to_register` label.

6. **Disassembling `mov_immediate_data_to_register`:**
   ```bash
   disas
   ```
   - The disassembler shows:
     ```
     0x08049001 <+0>: mov $0x64,%eax
     0x08049006 <+5>: movb $0x50,0x804a000
     ```
     - **`mov $0x64, %eax`:** Moves the value `0x64` (100 in decimal) into the `EAX` register.
     - **`movb $0x50, 0x804a000`:** Moves the byte value `0x50` into memory at address `0x804a000`.

7. **Inspecting Registers:**
   ```bash
   i r
   ```
   - Register `EAX` now holds `0x64` (decimal `100`), confirming the first instruction executed correctly.

---

### **What Happened?**
- The program executed the first `mov` instruction (`mov eax, 100`), successfully moving the immediate value `100` into the `EAX` register.
- Execution is currently at `movb $0x50, 0x804a000`, where it will store the immediate value `0x50` (80 in decimal) into the memory location `0x804a000`.

---

### **Key Observations**
1. **Address of `buffer`:**
   - The `.bss` section is uninitialized, and the memory address for `buffer` is assigned dynamically during linking. Here, `buffer` was resolved to `0x804a000`.
   - This matches the second instruction: `movb $0x50, 0x804a000`.

2. **Registers State:**
   - The `eax` register now holds the expected value (`100` in decimal), confirming that the first `mov` instruction executed as intended.

3. **EFLAGS Register:**
   - The `eflags` value of `0x202` indicates the **interrupt flag (IF)** is set, meaning interrupts are enabled. No other noteworthy flags are affected.

---

### **What to Do Next?**
- Step through the remaining instructions using `si` to verify the memory operation (`movb $0x50, 0x804a000`).
- Inspect memory at `0x804a000` after executing the `movb` instruction:
  ```bash
  x/1xb 0x804a000
  ```
  This will display the single byte at the memory address to confirm that `0x50` was written successfully.

---

### **Debugging Tips**
1. **Enable Debug Symbols:**
   Recompile your program with `-g` to include debugging symbols. This makes debugging easier by showing symbolic names for memory locations and labels.
   ```bash
   nasm -f elf32 -g -F dwarf moving_immediate_data.asm -o moving_immediate_data.o
   ld -m elf_i386 moving_immediate_data.o -o moving_immediate_data
   ```

2. **Verify the `.bss` Section:**
   Use tools like `objdump` or `readelf` to inspect the `.bss` section and confirm that `buffer` was allocated at the expected address.

3. **Disassemble the Entire Program:**
   Use `objdump -d` to disassemble the entire binary:
   ```bash
   objdump -d moving_immediate_data
   ```

---

### **Correct Way to Inspect Memory in GDB**

1. **Verify Memory Address of `buffer`:**
   Since `buffer` resides in the `.bss` section, its address is assigned dynamically. The `movb $0x50, 0x804a000` instruction suggests its address is `0x804a000`. You can directly inspect this address.

   ```bash
   x/1xb 0x804a000
   ```
   - `x`: Examine memory.
   - `/1x`: Display 1 value in hexadecimal format.
   - `b`: Treat it as a byte.

2. **Check Memory Content After `movb`:**
   If the instruction `movb $0x50, 0x804a000` has executed, the memory at `0x804a000` should now contain `0x50`. Use:
   ```bash
   x/1xb 0x804a000
   ```
   Expected output:
   ```
   0x804a000: 0x50
   ```

3. **Inspect `buffer` Symbol:**
   If GDB can't resolve `buffer` as a symbol, ensure the binary has debugging symbols by compiling with the `-g` flag during assembly:
   ```bash
   nasm -f elf32 -g -F dwarf moving_immediate_data.asm -o moving_immediate_data.o
   ld -m elf_i386 moving_immediate_data.o -o moving_immediate_data
   ```

4. **Print Symbolic Address of `buffer`:**
   Once debug symbols are enabled, you can display the address of `buffer`:
   ```bash
   print &buffer
   ```

5. **Explicit Memory Examination Using Symbol:**
   After confirming `buffer`'s address, examine its content directly:
   ```bash
   x/1xb &buffer
   ```

---

### **Addressing Common Issues**

1. **`buffer` has an unknown type:**
   This occurs because the binary lacks debugging symbols. Recompile the program with `-g` as shown above to include symbol information.

2. **`x/xb` requires an argument:**
   The `x` command needs a starting memory address. If `buffer` is unresolved, use its hardcoded address (`0x804a000` in this case).

3. **Check for Compiler Warnings:**
   If you're still unable to inspect memory, confirm that `buffer` was properly allocated in the `.bss` section. Use:
   ```bash
   objdump -t moving_immediate_data | grep buffer
   ```
   This will list `buffer`'s symbol and its resolved address.

---

### **Quick Debugging Script**
Here’s a series of commands to run in GDB for your current scenario:

```bash
b _start                    # Set breakpoint at _start
r                           # Run program
si                          # Step into mov_immediate_data_to_register
x/1xb 0x804a000             # Check memory at buffer's address
print &buffer               # Check buffer's symbolic address (if debug symbols exist)
```

---

### **Additional Debugging Tools**
1. **`readelf`:**
   Use `readelf -s moving_immediate_data` to inspect symbols and verify `buffer` is in `.bss`.

2. **`objdump`:**
   Use `objdump -d moving_immediate_data` to verify the disassembly and confirm that instructions match expectations.

These steps should help you confidently inspect `buffer` and verify the behavior of your assembly program.
